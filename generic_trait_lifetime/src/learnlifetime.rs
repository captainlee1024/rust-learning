// 生命周期于有效引用

// 生命周期避免了悬垂引用
// 如下：外部作用域声明了一个没有初始值的变量r, 在内部声明了一个初始值为5的变量x, 在内部作用域中,
// 我们尝试将r的值设置为一个x的引用。
// 但是, 变量x并没有处在的足够久，x在内部作用域结束 '}' 那一行就离开了作用域, 被释放掉了,
// 但是r在外部作用域是有效的, 如果这段代码继续工作, r将会引用在x离开作用域时被释放的内存
// 作用域越大我们就说它存在的越旧
/*
#[test]
fn test_lifetime1() {
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
*/

// 借用检查器
// rust 编译器又一个借用检查器 borrow checker , 它比较作用域来确保所有的借用都是有效的

// 函数中的泛型生命周期
// 生命周期注解语法
// eg:
// &i32 //引用
// &'a i32 //带有显示生命周期的引用
// &'a mut i32 //带有显示生命周期的可变引用
// 单个的生命周期注解本身没有多少意义，因为生命周期注解告诉rust多个引用的泛型生命周期
// 参数如何相互联系的。例如如果函数又一个生命周期'a的

// 函数签名中的生命周期注解
#![allow(unused)]
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
